<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IMU Lab Report</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 40px;
            padding: 20px;
            background-color: #f4f4f4;
        }
        h1, h2 { color: #333; }
        .container { 
            background: white; 
            padding: 20px; 
            border-radius: 8px; 
            box-shadow: 0px 0px 10px rgba(0,0,0,0.1); 
        }
        img { 
            max-width: 100%; 
            height: auto; 
            display: block; 
            margin: 10px auto; 
        }
        iframe { 
            display: block; 
            margin: 10px auto; 
        }
        pre { 
            background: #f4f4f4; 
            padding: 10px; 
            border-radius: 5px; 
            overflow-x: auto; 
        }
        .answer-box { 
            background: #eef; 
            padding: 10px; 
            margin: 10px 0; 
            border-left: 5px solid #36c; 
        }
        table { 
            width: 100%; 
            border-collapse: collapse; 
            margin-top: 10px; 
        }
        th, td { 
            border: 1px solid black; 
            padding: 8px; 
            text-align: left; 
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>IMU Lab Report</h1>

        <h2>Objective</h2>
        <p>This lab focuses on setting up and analyzing IMU data from the SparkFun Artemis board.</p>

        <h2>IMU Setup</h2>
        <h3>IMU Connection</h3>
        <p>To set up the IMU, I plugged it into the Artemis and then ran the example code provided to ensure it was working as intended.</p>
         <h4>Hardware Connection:</h4>
            <img src="Setup.png" alt="Screenshot showing virtual environment setup in command prompt" style="width: 400px; height: auto;">

        <h3>AD0_VAL Definition</h3>
        <p>In the example code, AD0_VAL is assigned a value of 1, signifying that the ADR jumper on the IMU has not been bridged. 
            This setting designates the IMU’s address as 0x69, making SPI communication possible. If the jumper were soldered, 
            SPI communication would be disabled.</p>
     

        <h3>IMU Basic Testing & Observations</h3>
        <p>Using the example code, I tested the IMU by applying different types of movement. When the IMU accelerates in a particular direction, only the 
            corresponding accelerometer values change, while the gyroscope shows minimal variation. During rotation, the accelerometer readings fluctuate 
            continuously, whereas the gyroscope detects changes only while the motion is happening. When flipped, the accelerometer readings adjust as different 
            axes align with gravity. Once the IMU remains at a fixed angle, the gyroscope records small values since it measures angular velocity rather than absolute 
            position. The video below illustrates these behaviors as the IMU is flipped, rotated, and accelerated. </p>
            <iframe width="560" height="315" src="https://www.youtube.com/embed/cwQI92nllOE" frameborder="0" allowfullscreen></iframe>

        <h3>LED Startup Indicator</h3>
        <p>I added code to make the Artemis blue light blink, indicating that the IMU is properly connected.</p>
        <iframe width="560" height="315" src="https://www.youtube.com/embed/osahaI1ORS4" frameborder="0" allowfullscreen></iframe>
          <h4>Blink Code:</h4>
            <img src="blinkwhenstart.png" alt="Screenshot showing virtual environment setup in command prompt" style="width: 400px; height: auto;">


        <h2>Accelerometer</h2>
        <h3>Pitch & Roll Equations</h3>
        <img src="pitchroll.png" alt="Accelerometer Output">

        <h3>Pitch & Roll at -90°, 0°, 90°</h3>
        <p>Readings seen in video:</p>
        <iframe width="560" height="315" src="https://www.youtube.com/embed/TvlEFKEUYQ4" frameborder="0" allowfullscreen></iframe>

        <h3>Accelerometer Accuracy</h3>
        <p>The accelerometer accuracy seems to be alright if it is held steady at an angle. Even then, the sensor readings will keep changing. A fourier 
            transform will assist with filtering out the noise from the sensor readings.</p>
       
        <h3>Fourier Transform Analysis</h3>
        <p>I sent data from arduino to python, and then did a fourier transform to better see what area of signal the noise was located. The graph of my fourier 
            transform lead me to select a cutoff frequency of 5 hertz, as below this level is where the noise is. 
            Here are graphs of my raw data of pitch and roll vs time along with the FFT plots. Note: the Frequency axis here should be scaled by 10,000.</p>
       <h4>Raw Roll:</h4>
            <img src="graphroll.png" alt="." style="width: 400px; height: auto;">
        <h4>Raw Pitch:</h4>
            <img src="graphpitch.png" alt="." style="width: 400px; height: auto;">
        <h4>FFT Roll:</h4>
            <img src="graphfftroll.png" alt="." style="width: 400px; height: auto;">
        <h4>FFT Pitch:</h4>
            <img src="graphfftpitch.png" alt="." style="width: 400px; height: auto;">
     
        <h3>Low-Pass Filter Implementation</h3>
         <p>I implemented a low pass filter to clean the noise out of the raw pich and roll data. I used .1 as my alpha, which is calculate from 
             dt = 1/(sampling rate), RC = 1/(2*pi*cutoff freq), and alpha=dt/(dt+RC) using a sampling rate of about 270 message/min and a cutoff frequency of 5 Hz. 
             Note: the Frequency axis here should be scaled by 10,000. </p>
         <h4>LPF Code:</h4>
            <img src="lpfcode.png" alt="." style="width: 400px; height: auto;">
        <h4>LPF Roll:</h4>
            <img src="afterLPF.png" alt="." style="width: 400px; height: auto;">
        <h4>LPF Pitch:</h4>
            <img src="afterLPFpitch.png" alt="." style="width: 400px; height: auto;">
        <h4>LPF Roll:</h4>
            <img src="fourierlpfroll.png" alt="." style="width: 400px; height: auto;">
        <h4>LPF Pitch:</h4>
            <img src="fourierlpfpitch.png" alt="." style="width: 400px; height: auto;">
       

        <h2>Gyroscope</h2>
        <h3>Pitch, Roll, and Yaw Computation</h3>
               <h4>Gyroscope Code:</h4>
            <img src="gyrocode.png" alt="." style="width: 600px; height: auto;">
         <h3>Gyroscope readings vs. Accelerometer:</h3>
        <h4>Pitch:</h4>
            <img src="steadygyropitch.png" alt="." style="width: 600px; height: auto;">
        <h4>Roll:</h4>
            <img src="steadygyro.png" alt="." style="width: 600px; height: auto;">
        <h4>Yaw:</h4>
            <img src="steadygyroyaw.png" alt="." style="width: 600px; height: auto;">
        <h3>Discussion</h3>
         <p> The data indicates that  the gyroscope exhibits significantly less noise than the accelerometer, but tends to drift over time. 
        The accelerometer provides more accurate readings when the IMU remains in a fixed position. Increasing the sampling frequency enhances 
        the gyroscope’s accuracy by allowing for more frequent updates. To achieve a more reliable signal, I implemented a complementary filter 
        that combines both accelerometer and gyroscope measurements 
        using weighting factor of 0.8 to give more emphasis to the accelerometer's readings, as they proved to be more accurate. The filter removes noise and drift
             from the input signal. 
         
         </p>

        <h3>Complementary Filter</h3>
        <h4>CF Code:</h4>
            <img src="cfcode.png" alt="." style="width: 600px; height: auto;">
        <h4>CF Pitch:</h4>
            <img src="cfpitch.png" alt="." style="width: 600px; height: auto;">
        <h4>CF Roll:</h4>
            <img src="lpf roll.png" alt="." style="width: 600px; height: auto;">

        <h2>Sample Data</h2>
        <h3>IMU Sampling Speed: I rewrote my main Arduin loop, removing all prints and delays. The resulting Arduino loop runs faster (362Hz) than the IMU can process data (48Mhz). 
            </h3>
                <h4>Final Loop Code, storing data in arrays:</h4>
            <img src="lpf roll.png" alt="." style="width: 600px; height: auto;">
        <div class="answer-box">[Your answer here]</div>

        <h3>Stored IMU Data</h3>
        <table>
            <tr>
                <th>Time (ms)</th><th>Pitch</th><th>Roll</th><th>Yaw</th>
            </tr>
            <tr>
                <td>100</td><td>0.25</td><td>-0.30</td><td>0.10</td>
            </tr>
            <tr>
                <td>200</td><td>0.50</td><td>-0.20</td><td>0.15</td>
            </tr>
        </table>

        <h3>Bluetooth Data Transmission</h3>
        <div class="answer-box">[Your answer here]</div>

        <h2>Recording a Stunt</h2>
        <h3>Car Setup</h3>
        <p>Include a video of your RC car experiment.</p>
        <iframe width="560" height="315" src="path/to/stunt_video.mp4" frameborder="0" allowfullscreen></iframe>

        <h3>Observations from Playing with the Car</h3>
        <div class="answer-box">[Your answer here]</div>

        <h2>Conclusion</h2>
        <div class="answer-box">[Your final thoughts and future improvements]</div>

    </div>
</body>
</html>

